# goit-js-hw-06

-----КОНТЕКСТ ВИКОНАННЯ ФУНКЦІЇ-----

Під час виклику функції у this записується посилання на об'єкт, у контексті якого вона була викликана. Таким чином, у тілі функції ми можемо отримати доступ до властивостей і методів цього об'єкта.

Значення this визначається не на момент оголошення функції (за винятком стрілкових функцій), а на момент її виклику. Іншими словами, this визначається тим, як саме функцію викликали, а не де вона була оголошена.

У глобальному контексті, якщо функція виконується не в суворому режимі, this посилається на об'єкт window. Об'єкт window надає доступ до браузерних властивостей і функцій та є глобальним контекстом виконання для скриптів у браузері.
У суворому режимі значення this у глобальному контексті завжди буде undefined.

foo.call(thisArg, arg1, arg2, ...)

Метод apply є аналогом методу call. Відмінність у тому, що в методі apply() синтаксис передачі аргументів вимагає масиву, навіть якщо аргументи функції — це окремі значення.
foo.apply(thisArg, [arg1, arg2, ...])

Метод bind створює і повертає нову функцію, яка має заздалегідь встановлений контекст, і ця нова функція може бути викликана пізніше з будь-якими аргументами.
const boundFoo = foo.bind(thisArg, arg1, arg2, ...)

this усередині стрілки посилається на контекст батьківської області видимості, в якій вона була оголошена, і ніколи не змінюється.
На відміну від звичайних функцій, змінити значення this усередині стрілки після її оголошення неможливо. Це означає, що методи call, apply і bind не впливають на значення this у стрілках.

Крок 1
Це стрілочна функція?
Якщо відповідь Так, значення this те саме, що у this у зовнішній області видимості
Якщо відповідь Ні, переходь на Крок 2
Крок 2
Чи використовуються методи call, apply або bind?
Якщо відповідь Так, значення this — це той самий об’єкт, що передали при їх виклику
Якщо відповідь Ні, переходь на Крок 3
Крок 3
Функція викликається як метод об’єкта object.method?
Якщо відповідь Так, значення this — це об’єкт ліворуч від крапки
Якщо відповідь Ні, переходь на Крок 4
Крок 4
Скрипт виконується в суворому режимі?
Якщо відповідь Так, значення this — undefined
Якщо відповідь Ні, значення this — window

-----ПРОТОТИПИ-----

Метод Object.create(obj) створює і повертає новий об'єкт, зв'язуючи його з об'єктом obj
Об'єкт, на який вказує посилання у властивості [[Prototype]], називається прототипом — це резервне сховище властивостей і методів об'єкта, яке автоматично використовується під час їх пошуку.

Якщо в коді потрібно перевірити, чи є об'єкт прототипом іншого об'єкта, використовується метод isPrototypeOf().

Для того щоб перевірити, чи є в об'єкті власна властивість, використовується метод obj.hasOwnProperty(key). Цей метод перевіряє наявність власної властивості з ім'ям key і повертає true, якщо є, і false в іншому випадку.

Методи Object.keys(obj) і Object.values(obj) повертають масив тільки власних ключів або значень тільки власних властивостей об'єкта obj, без необхідності додаткових перевірок.

Об'єкт, який виступає прототипом для іншого об'єкта, також може мати свій прототип. Отже, існують ланцюжки прототипів.

Наприкінці ланцюжка прототипів завжди знаходиться посилання на базовий клас, від якого походить тип даних у ланцюжку

-----ООП-----

Процедурне програмування — це парадигма програмування, у якій програми структуровані у вигляді набору функцій, які виконують певні дії над даними.

Основною одиницею програми є функції. Вони призначені для виконання конкретних завдань. Функції приймають аргументи (вхідні дані), обробляють їх і можуть повертати результат (вихідні дані).

Змінні, що оголошуються в межах функції, є локальними й доступними лише в цій функції. Змінні, оголошені поза функціями, є глобальними й доступними в усій програмі.

Об'єктно-орієнтоване програмування (ООП) — це парадигма програмування, в якій програми структуровані як сукупність об'єктів.

Клас — це спосіб опису сутності, що визначає структуру та поведінку об'єктів, а також правила для взаємодії з цією сутністю (контракт). Вони виступають в якості шаблонів для створення нових об'єктів.

Екземпляр (об'єкт, інстанція) — це окремий представник класу, який має дані (властивості) і методи (функції), які працюють з цими даними.

Інтерфейс — це набір властивостей і методів класу, доступних для використання у роботі з екземпляром.

-----КЛАСИ-----

Оголошення класу має такий синтаксис:
ключове слово class
ім’я класу (у прикладі: User)
тіло класу у фігурних дужках
class User {
// Тіло класу
}

Класи прийнято називати з великої літери, а в назві відображати тип об'єкта (іменника), що створюється.

Для ініціалізації екземпляра класу використовується метод constructor.

Методи класу — це функції, які будуть доступні екземпляру в його прототипі. Вони оголошуються в довільному порядку після конструктора. На відміну від синтаксису методів об'єкта (вони розділяються комою), методи класу не розділені жодними спеціальними символами.

Для доступу до властивостей у методах використовується ключове слово this, оскільки методи будуть викликані в контексті об'єкта-екземпляра.

Методи класу не стають власними властивостями екземпляра, оскільки, на відміну від значень властивостей, вони не є унікальними. Це одна й та сама функція, яка викликається в контексті різних об'єктів.

Інкапсуляція — це парадигма ООП, яка передбачає приховування деталей внутрішньої реалізації класу від зовнішнього коду

Додаючи до імені властивості на початку символ #, ми робимо її приватною. Оголошення приватної властивості до ініціалізації в конструкторі є обов'язковим.

Для того щоб отримати або змінити значення приватної властивості використовуються публічні методи.

Геттери і сеттери — це спеціальний синтаксис оголошення методів для взаємодії з властивостями.

Щоб оголосити геттер і сеттер, потрібно поставити перед ім'ям властивості відповідні ключові слова — get і set. Всередині цих методів:
повертаємо значення приватної властивості #email за допомогою геттера
змінюємо її значення за допомогою сеттера

Властивості, що доступні тільки класові, але не його екземплярам — це статичні властивості.

Статичні властивості оголошуються в тілі класу. Перед ім'ям властивості додається ключове слово static. Статичні властивості можна використовувати як у методах класу, так і поза класом
class MyClass {
static myProp = "value";
}
console.log(MyClass.myProp); // "value"

Статичні методи — це методи, доступні тільки класу. Вони можуть бути публічні та приватні.

Ключове слово extends дозволяє реалізувати наслідування класів, коли один клас (дочірній, похідний) наслідує властивості й методи іншого класу (батьківського).

У конструкторі дочірнього класу необхідно викликати спеціальну функцію super(args) — це псевдонім конструктора батьківського класу.

Дочірній клас може використовувати методи та властивості батьківського класу. Крім цього, у дочірньому класі можна оголошувати методи, які будуть доступні тільки його екземплярам.
